\section{Types and Terms and Judgments}
We now delve into the study of type theory. We write $a : A$ to mean that $a$ is a term of type $A$, where the 
colon signifies a kind of membership relation.
Types and terms can be understood through a set-theoretic interpretation. In this view, a type is analogous to 
a set, it classifies a collection of mathematical objects (terms) that belong to it. For example, the 
type $\mathbb{N}$ classifies terms like $0, 1, 2, \ldots$.

From a logical perspective, inspired by the Curry–Howard correspondence, a type can also be seen as a proposition, 
and the terms inhabiting the type are proofs of that proposition. For instance, the type $P \to Q$ (implication) 
is inhabited by functions that transform proofs of $P$ into proofs of $Q$.

Finally, a type specifies the shape of data structures or functions, enforcing which operations are valid. 
You might have worked with programming languages with type systems such where in order to use some 
primitive data structure such as string or int or float ecc ecc.
The type system is used by the compiler to be bale to infer the tyope of the varibale and allow ceratin operations 
and throwing errors in case this operation are not allowes on that specific tyope.
For instance in C Typescripot...
yuou have to specify it's type.


Lean has an extremely powerfull type system indeed and derived by type theory
\begin{example}
    \begin{lstlisting}[language=Lean]
    
    def m : Nat := 1       -- m is a natural number
    def n : Nat := 0
    
    #check m            -- output: Nat
    #check n
    
    \end{lstlisting}
\end{example}

A type judgment has the form $\Gamma \vdash t : T$,
 meaning: under \textbf{context} $\Gamma$ (a list of typed variables), the term $t$ has type $T$.
% \begin{example}
% We write
% $$\Gamma \vdash e : \tau$$
% to denote ``$e$ has type $\tau$ in context $\Gamma$''.
% \end{example}
Analogous to deduction rules, \textbf{type judgments} are formal assertions about the validity of types and terms.
\begin{example}
    \[
\begin{array}{c}
\Gamma \vdash t : A \qquad \Gamma \vdash A = B \\ [1ex]
\hline
\Gamma \vdash t : B \quad \text{(Type Equality)}
\end{array}
\]
\end{example}
\begin{example}
The Lean kernel uses type judgments.
    \begin{lstlisting}[language=Lean]
#check 2 + 2  -- ⊢ 2 + 2 : Nat (Judgment: This term has type Nat)
#eval 2 + 2   -- ⊢ 4 : Nat      (Judgment: Computes to 4, which is a Nat)

\end{lstlisting}
\end{example}


Using formal inference rules in the type judgment system, such as \textbf{introduction} and \textbf{elimination} 
rules, we can construct new types from existing ones. In addition to these, 
we also require \textbf{formation rules}, which specify when and how a type is well-formed, 
and \textbf{computation rules}, which describe how terms can be \textbf{normalized} (to be described later). 
(INTRODUCE SIMPLY TYPED LAMBDA CALCULUS HERE WITH REDUCTION STRONG NORMLIZATION ADN FIRST LOOK AT SIMPLE TYPE THEORY)
