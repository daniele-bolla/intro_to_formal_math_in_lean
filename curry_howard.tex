\section{Curry–Howard Correspondence}
We have been preparing for this argument, and the reader will have surely 
noticed a strong similarity when defining logical connectives 
using deduction rules; they are remarkably similar to types constructed 
using type judgments. For instance, function types can be seen as implications.
This is not a coincidence, but rather a fundamental theorem first proven by 
Haskell Curry and William Howard. It forms the core of modern type theory and 
establishes a deep connection between logic, computation, and mathematics.
The following table represents the Curry-Howard correspondence 
(also known as the Curry-Howard isomorphism)
\begin{table}[htbp]
\centering
\caption{Curry-Howard Correspondence: Logic and Type Theory}


\begin{align}
\text{Propositions} &\leftrightarrow \text{Types} \\
\text{Proofs} &\leftrightarrow \text{Programs} \\
\text{Proof Normalization} &\leftrightarrow \text{Program Evaluation}
\end{align}

\textbf{Implication} ($P \Rightarrow Q$) corresponds to the \textbf{function type} ($P \to Q$). 
A proof of an implication is a function that transforms any proof of the premise into a proof of the conclusion.

\textbf{Conjunction} ($P \land Q$) corresponds to the \textbf{product type} ($P \times Q$). 
A proof of a conjunction consists of a pair containing proofs of both conjuncts.

\textbf{Disjunction} ($P \lor Q$) corresponds to the \textbf{sum type} ($P + Q$). 
A proof of a disjunction is either a proof of the first disjunct or a proof of the second disjunct.

\textbf{Universal quantification} ($\forall x:A.P(x)$) corresponds to the \textbf{dependent product type} 
($\prod x:A.P(x)$). 
A proof of a universal statement is a function that, given any element of the domain, 
produces a proof of the property for that element.

\textbf{Existential quantification} ($\exists x:A.P(x)$) corresponds to the \textbf{dependent sum type} 
($\sum x:A.P(x)$). A proof of an existential statement consists of a witness element and a proof 
that this element satisfies the required property.
\textbf{Negation} ($\neg P$) corresponds to the \textbf{function type to the empty type} ($P \to \bot$).

\begin{tabular}{|l|c|l|l|}
\hline
\textbf{Logic} & \textbf{Symbol} & \textbf{Type Theory} & \textbf{Lean Notation} \\
\hline
\hline
\multicolumn{4}{|c|}{\textbf{Basic Correspondence}} \\
\hline
Proposition & $P$ & Type & \textbf{Type} \\
Proof & $\pi$ & Term/Program & \textbf{t : T} \\
\hline
\hline
\multicolumn{4}{|c|}{\textbf{Logical Connectives}} \\
\hline
Conjunction & $P \land Q$ & Product Type & \textbf{P} $\times$ \textbf{Q} \\
Disjunction & $P \lor Q$ & Sum Type & \textbf{P + Q} \\
Implication & $P \to Q$ & Function Type & \textbf{P $\to$ Q} \\
Biconditional & $P \leftrightarrow Q$ & Isomorphism & \textbf{P $\leftrightarrow$ Q} \\
Negation & $\neg P$ & Function to Empty & \textbf{P $\to$ False} \\
\hline
\hline
\multicolumn{4}{|c|}{\textbf{Constants}} \\
\hline
True & $\top$ & Unit Type & \textbf{True} or \textbf{Unit} \\
False & $\bot$ & Empty Type & \textbf{False} or \textbf{Empty} \\
\hline
\hline
\multicolumn{4}{|c|}{\textbf{Quantifiers}} \\
\hline
Universal & $\forall x. P(x)$ & Dependent Product & $\textbf{(x : A)} \to \textbf{P x}$ \\
Existential & $\exists x. P(x)$ & Dependent Sum & \textbf{Sigma x : A, P x} \\
\multicolumn{4}{|c|}{\textbf{Proof Operations}} \\
\hline
Proof by cases & Case analysis & Pattern matching & \textbf{match ... with} \\
Modus ponens & $P, P \to Q \vdash Q$ & Function application & \textbf{f a} \\
$\land$-introduction & $P, Q \vdash P \land Q$ & Pair construction & \textbf{(a, b)} \\
$\land$-elimination & $P \land Q \vdash P$ & Projection & \textbf{p.1, p.2} \\
$\to$-introduction & $P \vdash Q \Rightarrow \vdash P \to Q$ & Lambda abstraction & \textbf{$\lambda$ x => t} \\
\hline
\end{tabular}
\end{table}

As a strategy for implementing the Curry-Howard isomorphism, Lean introduces a special type \textbf{Prop} to represent propositions, and provides constructors to build new propositions from existing ones.

\begin{example}[from Theorem Proving in Lean 4]
In Lean, logical connectives are implemented as functions that take propositions and return new propositions:

\begin{lstlisting}[language=Lean]
-- Define implication using function types
def Implies (p q : Prop) : Prop := p \to q

-- Check the types of built-in logical connectives
#check And -- Prop \to Prop \to Prop
#check Or -- Prop \to Prop \to Prop
#check Implies -- Prop \to Prop \to Prop

-- Declare some proposition variables
variable (p q r : Prop)

-- Build complex propositions using these constructors
#check And p q -- Prop
\end{lstlisting}

This demonstrates how Lean treats propositions as first-class types. The logical connectives And, Or, and Implies are type constructors that take propositions as arguments and produce new propositions. Notice how:

\begin{itemize}
\item And p q constructs the conjunction of propositions p and q
\item Or (And p q) r constructs a disjunction between the conjunction $(p \land q)$ and proposition r
\item Implies (And p q) (And q p) expresses that conjunction is commutative
\end{itemize}

\end{example}
\begin{example}[from Theorem Proving in Lean 4]
    The \textbf{\#print} command reveals the underlying proof term of a theorem,
 
    demonstrating how proofs are simply terms in Lean's type system:

\begin{lstlisting}[language=Lean]
theorem t1 : p \to q \to p := fun hp : p => fun hq : q => hp

#print t1
-- Output: theorem t1 : p \to q \to p := fun hp hq => hp
\end{lstlisting}

 The theorem \textbf{t1} proves the logical statement $p \to q \to p$, which reads as "if $p$ is true, then regardless of $q$, $p$ remains true." The proof term \textbf{fun hp : p => fun hq : q => hp} is a nested lambda function that:

\begin{enumerate}
\item Takes a proof \textbf{hp} that $p$ holds
\item Takes a proof \textbf{hq} that $q$ holds (though we don't use it)
\item Returns the original proof \textbf{hp} of $p$
\end{enumerate}

When we use \textbf{\#print t1}, Lean shows the simplified (or \textbf{normalized}) form of the proof term, revealing how the theorem is actually implemented as a function. This transparency demonstrates the Curry-Howard correspondence in action: the logical implication $p \to q \to p$ corresponds exactly to the function type that takes two arguments and returns the first one.
\end{example}


Lean evaluates proofs with type checking and simplifications (wich we technically call \textbf{normalization}).
In the following section, we’ll explore this concept in detail.
