\section{Product Types}

As another fundamental example $A \times B$ denotes the type of pairs $(A,B)$, called \textbf{product type}.

\paragraph{Formation Rule}
\[
  \frac{A : \mathsf{Type} \quad B : \mathsf{Type}}{A \times B : \mathsf{Type}}
\]

\paragraph{Introduction Rule (pairing)}
\[
  \frac{a : A \quad b : B}{(a, b) : A \times B}
\]

\paragraph{Elimination Rules (projections)}
\[
  \frac{p : A \times B}{\mathsf{fst}(p) : A}
  \qquad
  \frac{p : A \times B}{\mathsf{snd}(p) : B}
\]

\paragraph{Computation Rules}
\[
  \mathsf{fst}(a, b) \equiv a
  \qquad
  \mathsf{snd}(a, b) \equiv b
\]
\begin{notation}
    $\mathsf{fst}$ and $\mathsf{snd}$ represent the projections to the first and second components of a pair $(a, b)$, respectively.  
    In Lean, these can be accessed using \textbf{(a, b).1} and \textbf{(a, b).2}.
\end{notation}
\begin{example}
    
\end{example}
\begin{lstlisting}[language=Lean]
def myPair : Nat \times Bool := (3, true)

#eval myPair.1     -- Output: 3
#eval myPair.2     -- Output: true

\end{lstlisting}\
constructior in lean as copatternmatching 
https://brandonrozek.com/blog/lean4-tutorial/

diffretn way to definiing pairs using curry: A -> B -> C samne as A x B -> C
We can also define pairs using a function that takes two arguments:
\begin{lstlisting}[language=Lean]
def pair : Nat -> Bool -> Nat \times Bool := fun a b => (a, b)
#eval pair 3 true -- Output: (3, true)
\end{lstlisting}

we can also uncurry the pair using a function that takes two arguments:
\begin{lstlisting}[language=Lean]
def uncurry : (A \times B) -> C := fun p => (p.1, p.2)
#eval uncurry myPair -- Output: (3, true)
\end{lstlisting}


The \emph{sum type} $A + B$ consists of values that are either of type $A$ (tagged with \textbf{inl}) or of type $B$ (tagged with \textbf{inr}).

\paragraph{Formation Rule}
\[
  \frac{A : \mathsf{Type} \quad B : \mathsf{Type}}{A + B : \mathsf{Type}}
\]

\paragraph{Introduction Rules}
\[
  \frac{a : A}{\mathsf{inl}(a) : A + B}
  \qquad
  \frac{b : B}{\mathsf{inr}(b) : A + B}
\]

\paragraph{Elimination Rule (case analysis)}
\[
  \frac{ 
    e : A + B
    \quad
    x : A \vdash f(x) : C
    \quad
    y : B \vdash g(y) : C
  }{
    \mathsf{match}\ e\ \mathsf{with} \ \mathsf{inl}(x) \mapsto f(x) \mid \mathsf{inr}(y) \mapsto g(y) : C
  }
\]

\paragraph{Computation Rules}
\[
  \mathsf{match}\ \mathsf{inl}(a) \ \mathsf{with} \ \dots \equiv f(a)
  \qquad
  \mathsf{match}\ \mathsf{inr}(b) \ \mathsf{with} \ \dots \equiv g(b)
\]

\begin{example}[Sum Type in Leans]
    \begin{lstlisting}[language=Lean]

\end{lstlisting}
\end{example}

Why do we not have unions and intersections in type theory?
THey depend opn elements and not on types, moreover they are not closed under the type system.
The reason is that we can construct unions and intersections using sum types and product types.
b

case: (A -> C) -> (B -> C) -> (A + B) -> C
uncurrycase: (A + B) -> (A -> C) x (B -> C) -> C


Unit type emptyt product type one element
Empty type is empty coproduct

caseFalse: false -> C
impossibnle pattern
fale quo libit


more connectives wich are derived and not primiitvives
negatrion: P -> False
iff P -> Q and Q -> P

prove DeMorgan's law: in Lean
\begin{lstlisting}[language=Lean]   
theorem deMorgan (P Q : Prop) : ¬(P ∨ Q) ↔ ¬P ∧ ¬Q :=
  Iff.intro
    (assume h : ¬(P ∨ Q),
      And.intro
        (assume p : P, h (Or.inl p))
        (assume q : Q, h (Or.inr q)))
    (assume h : ¬P ∧ ¬Q,
      assume pq : P ∨ Q,
      match pq with
      | Or.inl p => h.left p
      | Or.inr q => h.right q
      end)
\end{lstlisting}